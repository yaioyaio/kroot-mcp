/**
 * AI 협업 모니터
 * AI 도구 사용을 추적하고 효과성을 분석
 */

import { EventEmitter } from 'eventemitter3';
import { createHash } from 'crypto';
import {
  AITool,
  AIUsageType,
  AISuggestionStatus,
  AIUsageDetection,
  AISuggestion,
  AISession,
  AIInteraction,
  AIEffectivenessMetrics,
  AIUsagePattern,
  AICodeQualityAnalysis,
  AICollaborationAnalysis,
  AIMonitorEvents,
  AIDetectionRule
} from './types/ai.js';
import {
  BaseEvent,
  EventCategory
} from '../events/types/base.js';
import { FileEvent, FileChangeAction } from '../events/types/file.js';
import { GitEvent, GitEventType } from '../events/types/git.js';

export class AIMonitor extends EventEmitter<AIMonitorEvents> {
  private detections: AIUsageDetection[] = [];
  private suggestions: Map<string, AISuggestion> = new Map();
  private sessions: Map<string, AISession> = new Map();
  private activeSessions: Map<AITool, AISession> = new Map();
  private detectionRules: Map<AITool, AIDetectionRule>;
  private readonly DETECTION_WINDOW = 3600000; // 1시간
  private readonly SESSION_TIMEOUT = 300000; // 5분
  private sessionTimeouts: Map<string, NodeJS.Timeout> = new Map();

  constructor() {
    super();
    this.detectionRules = this.initializeDetectionRules();
    this.startSessionCleanup();
  }

  /**
   * 감지 규칙 초기화
   */
  private initializeDetectionRules(): Map<AITool, AIDetectionRule> {
    const rules = new Map<AITool, AIDetectionRule>();

    // Claude 감지 규칙
    rules.set(AITool.CLAUDE, {
      tool: AITool.CLAUDE,
      patterns: {
        comment: [
          /Generated by Claude/i,
          /Claude AI/i,
          /anthropic.*claude/i
        ],
        code: [
          /claude_api/i,
          /anthropic.*sdk/i
        ],
        file: [
          /\.claude\//,
          /claude.*\.(md|txt|json)$/i
        ],
        process: [
          /claude/i,
          /anthropic/i
        ]
      },
      confidence: 0.8
    });

    // GitHub Copilot 감지 규칙
    rules.set(AITool.GITHUB_COPILOT, {
      tool: AITool.GITHUB_COPILOT,
      patterns: {
        comment: [
          /Copilot/i,
          /Generated by.*Copilot/i,
          /github\.copilot/i
        ],
        code: [
          /copilot/i
        ],
        file: [
          /\.copilot/,
          /copilot.*\.json$/i
        ],
        process: [
          /copilot/i,
          /github.*copilot/i
        ]
      },
      confidence: 0.75
    });

    // ChatGPT 감지 규칙
    rules.set(AITool.CHATGPT, {
      tool: AITool.CHATGPT,
      patterns: {
        comment: [
          /ChatGPT/i,
          /Generated by.*ChatGPT/i,
          /OpenAI.*GPT/i
        ],
        code: [
          /openai.*api/i,
          /gpt-[34]/i
        ],
        file: [
          /\.openai/,
          /chatgpt.*\.(md|txt|json)$/i
        ],
        process: [
          /chatgpt/i,
          /openai/i
        ]
      },
      confidence: 0.75
    });

    // Cursor 감지 규칙
    rules.set(AITool.CURSOR, {
      tool: AITool.CURSOR,
      patterns: {
        comment: [
          /Cursor/i,
          /Generated.*Cursor/i
        ],
        file: [
          /\.cursor/,
          /cursor.*\.json$/i
        ],
        process: [
          /cursor/i
        ]
      },
      confidence: 0.7
    });

    return rules;
  }


  /**
   * 세션 정리 시작
   */
  private startSessionCleanup(): void {
    setInterval(() => {
      const now = Date.now();
      for (const [sessionId, session] of this.sessions) {
        if (!session.endTime && now - session.startTime > this.SESSION_TIMEOUT) {
          this.endSession(sessionId);
        }
      }
    }, 60000); // 1분마다 확인
  }

  /**
   * 이벤트 분석
   */
  async analyzeEvent(event: BaseEvent): Promise<void> {
    switch (event.category) {
      case EventCategory.FILE:
        await this.analyzeFileEvent(event as FileEvent);
        break;
      case EventCategory.GIT:
        await this.analyzeGitEvent(event as GitEvent);
        break;
      case 'process' as EventCategory:
        await this.analyzeProcessEvent(event);
        break;
    }

    // 메트릭 업데이트
    this.updateMetrics();
  }

  /**
   * 파일 이벤트 분석
   */
  private async analyzeFileEvent(event: FileEvent): Promise<void> {
    if (event.data.action !== FileChangeAction.ADD && 
        event.data.action !== FileChangeAction.CHANGE) {
      return;
    }

    const filePath = event.data.newFile?.path || event.data.oldFile?.path;
    if (!filePath) return;

    const content = (event.data.newFile as any)?.content || '';
    const oldContent = (event.data.oldFile as any)?.content || '';

    // 각 AI 도구별 감지
    for (const [tool, rule] of this.detectionRules) {
      const detection = this.detectAIUsage(filePath, content, rule);
      if (detection) {
        this.addDetection(detection);
        
        // 코드 변경 추적
        if (oldContent && content !== oldContent) {
          const suggestion = this.trackSuggestion(
            tool,
            filePath,
            oldContent,
            content,
            detection.usageType
          );
          if (suggestion) {
            this.emit('suggestionTracked', suggestion);
          }
        }

        // 세션 관리
        this.updateSession(tool, detection);
      }
    }
  }

  /**
   * Git 이벤트 분석
   */
  private async analyzeGitEvent(event: GitEvent): Promise<void> {
    if (event.type === GitEventType.COMMIT_CREATED) {
      const commitData = event.data as any;
      const message = commitData.message || '';
      
      // AI 관련 커밋 메시지 패턴 확인
      for (const [tool, rule] of this.detectionRules) {
        if (rule.patterns.comment?.some(pattern => pattern.test(message))) {
          const detection: AIUsageDetection = {
            tool,
            usageType: AIUsageType.CODE_GENERATION,
            timestamp: Date.now(),
            confidence: 0.6,
            context: `Commit: ${message}`
          };
          this.addDetection(detection);
        }
      }
    }
  }

  /**
   * 프로세스 이벤트 분석
   */
  private async analyzeProcessEvent(event: BaseEvent): Promise<void> {
    const processData = event.data as any;
    const processName = processData.name || '';
    
    // 실행 중인 AI 도구 프로세스 감지
    for (const [tool, rule] of this.detectionRules) {
      if (rule.patterns.process?.some(pattern => pattern.test(processName))) {
        const detection: AIUsageDetection = {
          tool,
          usageType: AIUsageType.OTHER,
          timestamp: Date.now(),
          confidence: 0.7,
          context: `Process: ${processName}`
        };
        this.addDetection(detection);
        
        // 세션 시작
        if (!this.activeSessions.has(tool)) {
          this.startSession(tool);
        }
      }
    }
  }

  /**
   * AI 사용 감지
   */
  private detectAIUsage(
    filePath: string,
    content: string,
    rule: AIDetectionRule
  ): AIUsageDetection | null {
    let confidence = 0;
    let usageType = AIUsageType.OTHER;
    const evidence: string[] = [];

    // 파일 경로 패턴 확인
    if (rule.patterns.file) {
      for (const pattern of rule.patterns.file) {
        if (pattern.test(filePath)) {
          confidence += 0.3;
          evidence.push(`File path matches: ${pattern.source}`);
          break;
        }
      }
    }

    // 코드 패턴 확인
    if (rule.patterns.code && content) {
      for (const pattern of rule.patterns.code) {
        if (pattern.test(content)) {
          confidence += 0.4;
          evidence.push(`Code pattern found: ${pattern.source}`);
          usageType = this.inferUsageType(content);
          break;
        }
      }
    }

    // 주석 패턴 확인
    if (rule.patterns.comment && content) {
      for (const pattern of rule.patterns.comment) {
        const matches = content.match(pattern);
        if (matches) {
          confidence += 0.3;
          evidence.push(`Comment found: ${matches[0]}`);
          break;
        }
      }
    }

    if (confidence < rule.confidence * 0.5) {
      return null;
    }

    return {
      tool: rule.tool,
      usageType,
      timestamp: Date.now(),
      filePath,
      confidence: Math.min(confidence, 1),
      context: evidence.join(', ')
    };
  }

  /**
   * 사용 유형 추론
   */
  private inferUsageType(content: string): AIUsageType {
    // 테스트 관련
    if (content.match(/test|spec|describe|it\(/i)) {
      return AIUsageType.TESTING;
    }
    
    // 문서화 관련
    if (content.match(/\/\*\*|\*\s*@|README|docs\//i)) {
      return AIUsageType.DOCUMENTATION;
    }
    
    // 리팩토링 관련
    if (content.match(/refactor|improve|optimize/i)) {
      return AIUsageType.REFACTORING;
    }
    
    // 디버깅 관련
    if (content.match(/fix|bug|error|debug/i)) {
      return AIUsageType.DEBUGGING;
    }
    
    // 아키텍처 관련
    if (content.match(/architecture|design|pattern|structure/i)) {
      return AIUsageType.ARCHITECTURE;
    }
    
    // 기본값: 코드 생성
    return AIUsageType.CODE_GENERATION;
  }

  /**
   * 제안 추적
   */
  private trackSuggestion(
    tool: AITool,
    filePath: string,
    originalCode: string,
    suggestedCode: string,
    usageType: AIUsageType
  ): AISuggestion {
    const id = this.generateSuggestionId(tool, filePath, Date.now());
    
    // 수정 비율 계산
    const modificationRatio = this.calculateModificationRatio(originalCode, suggestedCode);
    
    const suggestion: AISuggestion = {
      id,
      tool,
      usageType,
      status: AISuggestionStatus.ACCEPTED, // 파일이 저장되었으므로 수락됨
      timestamp: Date.now(),
      filePath,
      originalCode,
      suggestedCode,
      acceptedCode: suggestedCode,
      modificationRatio
    };

    this.suggestions.set(id, suggestion);
    
    // 코드 품질 분석
    const qualityAnalysis = this.analyzeCodeQuality(suggestion);
    if (qualityAnalysis) {
      this.emit('qualityAnalyzed', qualityAnalysis);
    }

    return suggestion;
  }

  /**
   * 세션 시작
   */
  private startSession(tool: AITool): void {
    const sessionId = this.generateSessionId(tool);
    const session: AISession = {
      id: sessionId,
      tool,
      startTime: Date.now(),
      interactions: []
    };

    this.sessions.set(sessionId, session);
    this.activeSessions.set(tool, session);
    this.emit('sessionStarted', session);

    // 세션 타임아웃 설정
    const timeout = setTimeout(() => {
      this.endSession(sessionId);
    }, this.SESSION_TIMEOUT);
    this.sessionTimeouts.set(sessionId, timeout);
  }

  /**
   * 세션 종료
   */
  private endSession(sessionId: string): void {
    const session = this.sessions.get(sessionId);
    if (!session || session.endTime) return;

    session.endTime = Date.now();
    
    // 활성 세션에서 제거
    if (this.activeSessions.get(session.tool)?.id === sessionId) {
      this.activeSessions.delete(session.tool);
    }

    // 타임아웃 제거
    const timeout = this.sessionTimeouts.get(sessionId);
    if (timeout) {
      clearTimeout(timeout);
      this.sessionTimeouts.delete(sessionId);
    }

    this.emit('sessionEnded', session);
  }

  /**
   * 세션 업데이트
   */
  private updateSession(tool: AITool, detection: AIUsageDetection): void {
    let session = this.activeSessions.get(tool);
    
    if (!session) {
      this.startSession(tool);
      session = this.activeSessions.get(tool)!;
    }

    // 상호작용 추가
    const interaction: AIInteraction = {
      timestamp: detection.timestamp,
      type: detection.usageType,
      ...(detection.prompt && { prompt: detection.prompt }),
      ...(detection.suggestion && { response: detection.suggestion })
    };

    session.interactions.push(interaction);

    // 타임아웃 리셋
    const timeout = this.sessionTimeouts.get(session.id);
    if (timeout) {
      clearTimeout(timeout);
      const newTimeout = setTimeout(() => {
        this.endSession(session.id);
      }, this.SESSION_TIMEOUT);
      this.sessionTimeouts.set(session.id, newTimeout);
    }
  }

  /**
   * 수정 비율 계산
   */
  private calculateModificationRatio(original: string, modified: string): number {
    if (!original || !modified) return 1;
    
    const originalLines = original.split('\n');
    const modifiedLines = modified.split('\n');
    
    let changedLines = 0;
    const maxLines = Math.max(originalLines.length, modifiedLines.length);
    
    for (let i = 0; i < maxLines; i++) {
      if (originalLines[i] !== modifiedLines[i]) {
        changedLines++;
      }
    }
    
    return changedLines / maxLines;
  }

  /**
   * 코드 품질 분석
   */
  private analyzeCodeQuality(suggestion: AISuggestion): AICodeQualityAnalysis {
    const quality = {
      readability: this.assessReadability(suggestion.suggestedCode),
      maintainability: this.assessMaintainability(suggestion.suggestedCode),
      performance: this.assessPerformance(suggestion.suggestedCode),
      security: this.assessSecurity(suggestion.suggestedCode),
      testability: this.assessTestability(suggestion.suggestedCode)
    };

    const issues = this.detectIssues(suggestion.suggestedCode);
    const improvements = this.suggestImprovements(suggestion.suggestedCode, quality);

    return {
      suggestion,
      quality,
      issues,
      improvements
    };
  }

  /**
   * 가독성 평가
   */
  private assessReadability(code: string): number {
    let score = 100;
    
    // 긴 라인
    const lines = code.split('\n');
    const longLines = lines.filter(line => line.length > 120).length;
    score -= longLines * 2;
    
    // 복잡한 표현식
    const complexExpressions = code.match(/&&|\|\||[?:]/g)?.length || 0;
    score -= Math.min(complexExpressions * 1, 20);
    
    // 적절한 주석
    const commentLines = lines.filter(line => line.trim().match(/^\/\/|^\/\*|\*\//)).length;
    const commentRatio = commentLines / lines.length;
    if (commentRatio < 0.1) score -= 10;
    if (commentRatio > 0.3) score -= 5;
    
    return Math.max(0, score);
  }

  /**
   * 유지보수성 평가
   */
  private assessMaintainability(code: string): number {
    let score = 100;
    
    // 함수 길이
    const functions = code.match(/function\s+\w+|const\s+\w+\s*=\s*(?:async\s*)?\(/g) || [];
    if (functions.length > 0) {
      const avgFunctionLength = code.length / functions.length;
      if (avgFunctionLength > 500) score -= 20;
    }
    
    // 중복 코드
    const duplicatePatterns = this.findDuplicatePatterns(code);
    score -= duplicatePatterns * 5;
    
    // 모듈화
    const imports = code.match(/import|require/g)?.length || 0;
    const exports = code.match(/export/g)?.length || 0;
    if (imports === 0 && exports === 0 && code.length > 200) score -= 15;
    
    return Math.max(0, score);
  }

  /**
   * 성능 평가
   */
  private assessPerformance(code: string): number {
    let score = 100;
    
    // 비효율적인 루프
    const nestedLoops = code.match(/for.*{[\s\S]*?for/g)?.length || 0;
    score -= nestedLoops * 10;
    
    // 동기 파일 작업
    const syncFileOps = code.match(/readFileSync|writeFileSync/g)?.length || 0;
    score -= syncFileOps * 5;
    
    // 메모리 누수 가능성
    const globalVars = code.match(/^(?!.*const|let|var)\s*\w+\s*=/gm)?.length || 0;
    score -= globalVars * 3;
    
    return Math.max(0, score);
  }

  /**
   * 보안 평가
   */
  private assessSecurity(code: string): number {
    let score = 100;
    
    // SQL 인젝션 가능성
    if (code.match(/query.*\+|query.*\$\{/)) score -= 20;
    
    // eval 사용
    if (code.match(/eval\s*\(/)) score -= 30;
    
    // 하드코딩된 비밀번호
    if (code.match(/password\s*=\s*["'][\w]+["']/i)) score -= 25;
    
    // 안전하지 않은 정규식
    if (code.match(/\.\*/)) score -= 5;
    
    return Math.max(0, score);
  }

  /**
   * 테스트 가능성 평가
   */
  private assessTestability(code: string): number {
    let score = 100;
    
    // 순수 함수
    const functions = code.match(/function|=>/g)?.length || 0;
    const sideEffects = code.match(/console\.|document\.|window\.|process\./g)?.length || 0;
    if (functions > 0) {
      const sideEffectRatio = sideEffects / functions;
      score -= sideEffectRatio * 20;
    }
    
    // 의존성 주입
    const hardcodedDeps = code.match(/new\s+\w+\(/g)?.length || 0;
    score -= hardcodedDeps * 2;
    
    // 함수 크기
    const largeFunctions = code.split(/function|=>/).filter(part => part.length > 300).length;
    score -= largeFunctions * 10;
    
    return Math.max(0, score);
  }

  /**
   * 중복 패턴 찾기
   */
  private findDuplicatePatterns(code: string): number {
    const lines = code.split('\n').filter(line => line.trim().length > 10);
    const patterns = new Map<string, number>();
    
    for (let i = 0; i < lines.length - 2; i++) {
      const pattern = lines.slice(i, i + 3).join('\n');
      patterns.set(pattern, (patterns.get(pattern) || 0) + 1);
    }
    
    return Array.from(patterns.values()).filter(count => count > 1).length;
  }

  /**
   * 이슈 감지
   */
  private detectIssues(code: string): AICodeQualityAnalysis['issues'] {
    const issues: AICodeQualityAnalysis['issues'] = [];
    
    // 버그 가능성
    if (code.match(/==(?!=)/)) {
      issues.push({
        type: 'bug',
        severity: 'medium',
        description: 'Use === instead of == for comparison'
      });
    }
    
    // 보안 취약점
    if (code.match(/eval\s*\(/)) {
      issues.push({
        type: 'vulnerability',
        severity: 'critical',
        description: 'Avoid using eval() due to security risks'
      });
    }
    
    // 코드 스멜
    if (code.match(/TODO|FIXME|HACK/)) {
      issues.push({
        type: 'code_smell',
        severity: 'low',
        description: 'Unresolved TODO/FIXME comments found'
      });
    }
    
    // 성능 이슈
    if (code.match(/for.*{[\s\S]*?for.*{[\s\S]*?for/)) {
      issues.push({
        type: 'performance',
        severity: 'high',
        description: 'Triple nested loops detected'
      });
    }
    
    return issues;
  }

  /**
   * 개선 제안
   */
  private suggestImprovements(
    _code: string,
    quality: AICodeQualityAnalysis['quality']
  ): string[] {
    const improvements: string[] = [];
    
    if (quality.readability < 70) {
      improvements.push('Break down long lines and complex expressions');
      improvements.push('Add meaningful comments for complex logic');
    }
    
    if (quality.maintainability < 70) {
      improvements.push('Split large functions into smaller, focused ones');
      improvements.push('Extract common patterns into reusable functions');
    }
    
    if (quality.performance < 70) {
      improvements.push('Consider using async operations for I/O');
      improvements.push('Optimize nested loops with better algorithms');
    }
    
    if (quality.security < 70) {
      improvements.push('Use parameterized queries to prevent SQL injection');
      improvements.push('Store sensitive data in environment variables');
    }
    
    if (quality.testability < 70) {
      improvements.push('Use dependency injection for better testability');
      improvements.push('Separate business logic from side effects');
    }
    
    return improvements;
  }

  /**
   * 감지 추가
   */
  private addDetection(detection: AIUsageDetection): void {
    this.detections.push(detection);
    
    // 오래된 감지 제거
    const cutoff = Date.now() - this.DETECTION_WINDOW;
    this.detections = this.detections.filter(d => d.timestamp > cutoff);
    
    this.emit('aiUsageDetected', detection);
  }

  /**
   * 메트릭 업데이트
   */
  private updateMetrics(): void {
    for (const tool of Object.values(AITool)) {
      const metrics = this.calculateMetrics(tool as AITool);
      this.emit('metricsUpdated', metrics);
    }
  }

  /**
   * 메트릭 계산
   */
  private calculateMetrics(tool: AITool): AIEffectivenessMetrics {
    const recentSuggestions = Array.from(this.suggestions.values())
      .filter(s => s.tool === tool && s.timestamp > Date.now() - this.DETECTION_WINDOW);
    
    const accepted = recentSuggestions.filter(s => s.status === AISuggestionStatus.ACCEPTED).length;
    const modified = recentSuggestions.filter(s => s.status === AISuggestionStatus.MODIFIED).length;
    const total = recentSuggestions.length;
    
    const acceptanceRate = total > 0 ? accepted / total : 0;
    const modificationRate = total > 0 ? modified / total : 0;
    
    const responseTimes = recentSuggestions
      .filter(s => s.responseTime)
      .map(s => s.responseTime!);
    const averageResponseTime = responseTimes.length > 0
      ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
      : 0;
    
    // 코드 품질 영향 계산
    const qualityAnalyses = recentSuggestions
      .map(s => this.suggestions.get(s.id))
      .filter(s => s)
      .map(s => this.analyzeCodeQuality(s!));
    
    const bugsIntroduced = qualityAnalyses
      .reduce((sum, a) => sum + a.issues.filter(i => i.type === 'bug').length, 0);
    const bugsFixed = recentSuggestions
      .filter(s => s.usageType === AIUsageType.DEBUGGING).length;
    
    return {
      tool,
      timeWindow: 'hour',
      acceptanceRate,
      modificationRate,
      averageResponseTime,
      totalInteractions: total,
      successfulInteractions: accepted + modified,
      tokenEfficiency: 0.7, // 예시값
      timesSaved: total * 5, // 각 상호작용당 5분 절약 가정
      codeQualityImpact: {
        bugsIntroduced,
        bugsFixed,
        complexityChange: 0,
        testCoverageChange: 0
      }
    };
  }

  /**
   * 사용 패턴 분석
   */
  analyzeUsagePatterns(): Map<AITool, AIUsagePattern> {
    const patterns = new Map<AITool, AIUsagePattern>();
    
    for (const tool of Object.values(AITool)) {
      const toolDetections = this.detections.filter(d => d.tool === tool);
      
      if (toolDetections.length === 0) continue;
      
      // 가장 많이 사용된 유형
      const usageTypes = toolDetections.map(d => d.usageType);
      const typeCount = new Map<AIUsageType, number>();
      usageTypes.forEach(type => {
        typeCount.set(type, (typeCount.get(type) || 0) + 1);
      });
      const mostUsedTypes = Array.from(typeCount.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([type]) => type);
      
      // 피크 시간
      const hours = toolDetections.map(d => new Date(d.timestamp).getHours());
      const hourCount = new Map<number, number>();
      hours.forEach(hour => {
        hourCount.set(hour, (hourCount.get(hour) || 0) + 1);
      });
      const peakHours = Array.from(hourCount.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([hour]) => hour);
      
      // 세션 기간
      const sessions = Array.from(this.sessions.values())
        .filter(s => s.tool === tool && s.endTime);
      const avgDuration = sessions.length > 0
        ? sessions.reduce((sum, s) => sum + (s.endTime! - s.startTime), 0) / sessions.length / 60000
        : 0;
      
      const pattern: AIUsagePattern = {
        tool: tool as AITool,
        patterns: {
          mostUsedTypes,
          peakHours,
          averageSessionDuration: avgDuration,
          preferredFileTypes: this.getPreferredFileTypes(toolDetections),
          commonPromptPatterns: []
        },
        productivity: {
          linesGeneratedPerHour: this.calculateLinesPerHour(tool as AITool),
          functionsCompletedPerDay: this.calculateFunctionsPerDay(tool as AITool),
          testsWrittenPerWeek: this.calculateTestsPerWeek(tool as AITool)
        }
      };
      
      patterns.set(tool as AITool, pattern);
      this.emit('patternIdentified', pattern);
    }
    
    return patterns;
  }

  /**
   * 선호하는 파일 타입 가져오기
   */
  private getPreferredFileTypes(detections: AIUsageDetection[]): string[] {
    const fileTypes = detections
      .filter(d => d.filePath)
      .map(d => {
        const ext = d.filePath!.split('.').pop() || '';
        return ext;
      });
    
    const typeCount = new Map<string, number>();
    fileTypes.forEach(type => {
      typeCount.set(type, (typeCount.get(type) || 0) + 1);
    });
    
    return Array.from(typeCount.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5)
      .map(([type]) => type);
  }

  /**
   * 시간당 생성 라인 수 계산
   */
  private calculateLinesPerHour(tool: AITool): number {
    const hourAgo = Date.now() - 3600000;
    const recentSuggestions = Array.from(this.suggestions.values())
      .filter(s => s.tool === tool && s.timestamp > hourAgo);
    
    const totalLines = recentSuggestions
      .reduce((sum, s) => sum + (s.suggestedCode.split('\n').length || 0), 0);
    
    return totalLines;
  }

  /**
   * 일일 완성 함수 수 계산
   */
  private calculateFunctionsPerDay(tool: AITool): number {
    const dayAgo = Date.now() - 86400000;
    const recentSuggestions = Array.from(this.suggestions.values())
      .filter(s => s.tool === tool && s.timestamp > dayAgo);
    
    const totalFunctions = recentSuggestions
      .reduce((sum, s) => {
        const functions = s.suggestedCode.match(/function\s+\w+|const\s+\w+\s*=\s*(?:async\s*)?\(/g) || [];
        return sum + functions.length;
      }, 0);
    
    return totalFunctions;
  }

  /**
   * 주간 작성 테스트 수 계산
   */
  private calculateTestsPerWeek(tool: AITool): number {
    const weekAgo = Date.now() - 604800000;
    const recentSuggestions = Array.from(this.suggestions.values())
      .filter(s => s.tool === tool && s.timestamp > weekAgo && s.usageType === AIUsageType.TESTING);
    
    const totalTests = recentSuggestions
      .reduce((sum, s) => {
        const tests = s.suggestedCode.match(/test\s*\(|it\s*\(|describe\s*\(/g) || [];
        return sum + tests.length;
      }, 0);
    
    return totalTests;
  }

  /**
   * 협업 분석
   */
  analyze(): AICollaborationAnalysis {
    const tools: AICollaborationAnalysis['tools'] = {};
    const patterns = this.analyzeUsagePatterns();
    
    // 도구별 분석
    for (const [tool, pattern] of patterns) {
      const metrics = this.calculateMetrics(tool);
      tools[tool] = {
        sessions: Array.from(this.sessions.values()).filter(s => s.tool === tool).length,
        interactions: metrics.totalInteractions,
        acceptanceRate: metrics.acceptanceRate,
        timesSaved: metrics.timesSaved,
        preferredUsageTypes: pattern.patterns.mostUsedTypes
      };
    }
    
    // 전체 메트릭
    const totalAITime = Array.from(this.sessions.values())
      .filter(s => s.endTime)
      .reduce((sum, s) => sum + (s.endTime! - s.startTime), 0) / 60000;
    
    const humanCodingTime = totalAITime * 2; // 추정값
    const aiContributionRatio = totalAITime / (totalAITime + humanCodingTime);
    const productivityGain = (totalAITime / humanCodingTime) * 100;
    
    // 가장 효과적인 도구 찾기
    let mostEffectiveTool = AITool.OTHER;
    let maxEfficiency = 0;
    for (const [tool, data] of Object.entries(tools)) {
      const efficiency = (data?.acceptanceRate || 0) * (data?.interactions || 0);
      if (efficiency > maxEfficiency) {
        maxEfficiency = efficiency;
        mostEffectiveTool = tool as AITool;
      }
    }
    
    // 트렌드 계산
    const hourlyUsage = this.calculateHourlyTrends();
    
    return {
      timestamp: Date.now(),
      tools,
      overallMetrics: {
        totalAIAssistedTime: totalAITime,
        humanCodingTime,
        aiContributionRatio,
        productivityGain
      },
      insights: {
        mostEffectiveTool,
        bestUseCases: this.getBestUseCases(),
        improvementAreas: this.getImprovementAreas(),
        recommendations: this.generateRecommendations()
      },
      trends: {
        adoptionRate: hourlyUsage.adoption,
        qualityTrend: hourlyUsage.quality,
        efficiencyTrend: hourlyUsage.efficiency
      }
    };
  }

  /**
   * 시간별 트렌드 계산
   */
  private calculateHourlyTrends(): {
    adoption: number[];
    quality: number[];
    efficiency: number[];
  } {
    const hours = 24;
    const adoption: number[] = [];
    const quality: number[] = [];
    const efficiency: number[] = [];
    
    for (let i = 0; i < hours; i++) {
      const hourStart = Date.now() - (hours - i) * 3600000;
      const hourEnd = hourStart + 3600000;
      
      const hourDetections = this.detections.filter(
        d => d.timestamp >= hourStart && d.timestamp < hourEnd
      );
      
      adoption.push(hourDetections.length);
      
      const hourSuggestions = Array.from(this.suggestions.values()).filter(
        s => s.timestamp >= hourStart && s.timestamp < hourEnd
      );
      
      const avgQuality = hourSuggestions.length > 0
        ? hourSuggestions.reduce((sum, s) => {
            const analysis = this.analyzeCodeQuality(s);
            const totalQuality = Object.values(analysis.quality).reduce((a, b) => a + b, 0) / 5;
            return sum + totalQuality;
          }, 0) / hourSuggestions.length
        : 0;
      
      quality.push(avgQuality);
      
      const acceptRate = hourSuggestions.length > 0
        ? hourSuggestions.filter(s => s.status === AISuggestionStatus.ACCEPTED).length / hourSuggestions.length
        : 0;
      
      efficiency.push(acceptRate * 100);
    }
    
    return { adoption, quality, efficiency };
  }

  /**
   * 최고의 사용 사례 가져오기
   */
  private getBestUseCases(): AIUsageType[] {
    const usageStats = new Map<AIUsageType, { count: number; acceptRate: number }>();
    
    for (const suggestion of this.suggestions.values()) {
      const stats = usageStats.get(suggestion.usageType) || { count: 0, acceptRate: 0 };
      stats.count++;
      if (suggestion.status === AISuggestionStatus.ACCEPTED) {
        stats.acceptRate++;
      }
      usageStats.set(suggestion.usageType, stats);
    }
    
    return Array.from(usageStats.entries())
      .map(([type, stats]) => ({
        type,
        effectiveness: stats.count > 0 ? stats.acceptRate / stats.count : 0
      }))
      .sort((a, b) => b.effectiveness - a.effectiveness)
      .slice(0, 3)
      .map(item => item.type);
  }

  /**
   * 개선 영역 가져오기
   */
  private getImprovementAreas(): string[] {
    const areas: string[] = [];
    
    // 낮은 수락률
    const avgAcceptRate = this.calculateOverallAcceptanceRate();
    if (avgAcceptRate < 0.5) {
      areas.push('AI 제안의 수락률이 낮습니다. 프롬프트 개선이 필요합니다.');
    }
    
    // 높은 수정률
    const avgModRate = this.calculateOverallModificationRate();
    if (avgModRate > 0.3) {
      areas.push('AI 제안이 자주 수정됩니다. 더 정확한 컨텍스트 제공이 필요합니다.');
    }
    
    // 특정 도구 편중
    const toolUsage = this.calculateToolDistribution();
    const maxUsage = Math.max(...toolUsage.values());
    const totalUsage = Array.from(toolUsage.values()).reduce((a, b) => a + b, 0);
    if (maxUsage / totalUsage > 0.8) {
      areas.push('특정 AI 도구에 너무 의존하고 있습니다. 다양한 도구 활용을 고려하세요.');
    }
    
    return areas;
  }

  /**
   * 권장사항 생성
   */
  private generateRecommendations(): string[] {
    const recommendations: string[] = [];
    
    // 생산성 향상 - 기본 추천사항
    if (this.detections.length < 10) {
      recommendations.push('AI 도구를 더 적극적으로 활용하여 생산성을 향상시킬 수 있습니다.');
    }
    
    // 품질 개선
    const avgQuality = this.calculateAverageCodeQuality();
    if (avgQuality < 70) {
      recommendations.push('AI가 생성한 코드의 품질 검토를 강화하세요.');
    }
    
    // 최적 사용 시간
    const patterns = this.analyzeUsagePatterns();
    const peakHours = Array.from(patterns.values())
      .flatMap(p => p.patterns.peakHours)
      .filter((hour, index, self) => self.indexOf(hour) === index);
    
    if (peakHours.length > 0) {
      recommendations.push(`AI 도구는 주로 ${peakHours.join(', ')}시에 가장 효과적으로 사용됩니다.`);
    }
    
    // 기본 권장사항
    recommendations.push('코드 품질 향상을 위해 AI 생성 코드를 항상 검토하세요.');
    recommendations.push('다양한 AI 도구를 적절히 조합하여 사용하세요.');
    
    return recommendations;
  }

  /**
   * 전체 수락률 계산
   */
  private calculateOverallAcceptanceRate(): number {
    const suggestions = Array.from(this.suggestions.values());
    if (suggestions.length === 0) return 0;
    
    const accepted = suggestions.filter(s => s.status === AISuggestionStatus.ACCEPTED).length;
    return accepted / suggestions.length;
  }

  /**
   * 전체 수정률 계산
   */
  private calculateOverallModificationRate(): number {
    const suggestions = Array.from(this.suggestions.values());
    if (suggestions.length === 0) return 0;
    
    const modified = suggestions.filter(s => s.status === AISuggestionStatus.MODIFIED).length;
    return modified / suggestions.length;
  }

  /**
   * 도구 분포 계산
   */
  private calculateToolDistribution(): Map<AITool, number> {
    const distribution = new Map<AITool, number>();
    
    for (const detection of this.detections) {
      distribution.set(detection.tool, (distribution.get(detection.tool) || 0) + 1);
    }
    
    return distribution;
  }

  /**
   * 평균 코드 품질 계산
   */
  private calculateAverageCodeQuality(): number {
    const suggestions = Array.from(this.suggestions.values());
    if (suggestions.length === 0) return 0;
    
    const totalQuality = suggestions.reduce((sum, s) => {
      const analysis = this.analyzeCodeQuality(s);
      const avgQuality = Object.values(analysis.quality).reduce((a, b) => a + b, 0) / 5;
      return sum + avgQuality;
    }, 0);
    
    return totalQuality / suggestions.length;
  }

  /**
   * ID 생성 헬퍼
   */
  private generateSuggestionId(tool: AITool, filePath: string, timestamp: number): string {
    const hash = createHash('md5');
    hash.update(`${tool}-${filePath}-${timestamp}`);
    return hash.digest('hex').substring(0, 16);
  }

  private generateSessionId(tool: AITool): string {
    const hash = createHash('md5');
    hash.update(`${tool}-${Date.now()}-${Math.random()}`);
    return hash.digest('hex').substring(0, 16);
  }
}